<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: validator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: validator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module validator
 * @description Module de validation - Moteur de validation en JavaScript
 * @author Isma
 * @version 1.0.0
 */

/**
 * Vérifie si une personne est majeure (>= 18 ans) à partir de sa date de naissance.
 * 
 * @param {Date} birthDate - La date de naissance de la personne
 * @returns {Object} Objet contenant { valid: boolean, age: number, error?: string }
 * @throws {Error} INVALID_ARGUMENT - Si aucun argument ou argument null/undefined
 * @throws {Error} INVALID_DATE_TYPE - Si l'argument n'est pas une instance de Date
 * @throws {Error} INVALID_DATE - Si la Date est invalide (NaN)
 * @throws {Error} DATE_IN_FUTURE - Si la date de naissance est dans le futur
 * 
 * @example
 * // Personne majeure
 * const result = isAdult(new Date('1990-05-15'));
 * // { valid: true, age: 35 }
 * 
 * @example
 * // Personne mineure
 * const result = isAdult(new Date('2010-05-15'));
 * // { valid: false, age: 15, error: 'AGE_UNDER_18' }
 */
export function isAdult(birthDate) {
  // Validation des arguments
  if (birthDate === undefined || birthDate === null) {
    throw new Error('INVALID_ARGUMENT');
  }

  if (!(birthDate instanceof Date)) {
    throw new Error('INVALID_DATE_TYPE');
  }

  if (isNaN(birthDate.getTime())) {
    throw new Error('INVALID_DATE');
  }

  const today = new Date();
  
  if (birthDate > today) {
    throw new Error('DATE_IN_FUTURE');
  }

  // Calcul précis de l'âge
  const age = calculateAge(birthDate, today);

  // Vérification de la majorité
  if (age >= 18) {
    return { valid: true, age };
  } else {
    return { valid: false, age, error: 'AGE_UNDER_18' };
  }
}

/**
 * Calcule l'âge exact d'une personne en tenant compte du jour d'anniversaire.
 * Gère correctement le cas du 29 février.
 * 
 * @private
 * @param {Date} birthDate - Date de naissance
 * @param {Date} currentDate - Date actuelle
 * @returns {number} L'âge en années
 */
function calculateAge(birthDate, currentDate) {
  let age = currentDate.getFullYear() - birthDate.getFullYear();
  const monthDiff = currentDate.getMonth() - birthDate.getMonth();
  const dayDiff = currentDate.getDate() - birthDate.getDate();

  // Si l'anniversaire n'est pas encore passé cette année, on retire 1 an
  if (monthDiff &lt; 0 || (monthDiff === 0 &amp;&amp; dayDiff &lt; 0)) {
    age--;
  }

  return age;
}

/**
 * Valide un code postal français (5 chiffres exactement).
 * 
 * @param {string} postalCode - Le code postal à valider
 * @returns {Object} Objet contenant { valid: boolean, postalCode?: string, error?: string }
 * @throws {Error} INVALID_ARGUMENT - Si aucun argument ou argument null/undefined
 * @throws {Error} INVALID_TYPE - Si l'argument n'est pas une chaîne de caractères
 * 
 * @example
 * // Code postal valide
 * const result = isValidPostalCode('75001');
 * // { valid: true, postalCode: '75001' }
 * 
 * @example
 * // Code postal invalide
 * const result = isValidPostalCode('7500');
 * // { valid: false, error: 'INVALID_FORMAT' }
 */
export function isValidPostalCode(postalCode) {
  // Validation des arguments
  if (postalCode === undefined || postalCode === null) {
    throw new Error('INVALID_ARGUMENT');
  }

  if (typeof postalCode !== 'string') {
    throw new Error('INVALID_TYPE');
  }

  // Regex pour code postal français : exactement 5 chiffres
  const postalCodeRegex = /^[0-9]{5}$/;

  if (postalCodeRegex.test(postalCode)) {
    return { valid: true, postalCode };
  } else {
    return { valid: false, error: 'INVALID_FORMAT' };
  }
}

/**
 * Valide un nom ou prénom (sans chiffres ni caractères spéciaux, sauf accents et tirets).
 * Protège contre les injections XSS.
 * 
 * @param {string} name - Le nom ou prénom à valider
 * @returns {Object} Objet contenant { valid: boolean, name?: string, error?: string }
 * @throws {Error} INVALID_ARGUMENT - Si aucun argument ou argument null/undefined
 * @throws {Error} INVALID_TYPE - Si l'argument n'est pas une chaîne de caractères
 * 
 * @example
 * // Nom valide
 * const result = isValidName('Jean-Pierre');
 * // { valid: true, name: 'Jean-Pierre' }
 * 
 * @example
 * // Nom avec XSS
 * const result = isValidName('&lt;script>alert("xss")&lt;/script>');
 * // { valid: false, error: 'XSS_DETECTED' }
 */
export function isValidName(name) {
  // Validation des arguments
  if (name === undefined || name === null) {
    throw new Error('INVALID_ARGUMENT');
  }

  if (typeof name !== 'string') {
    throw new Error('INVALID_TYPE');
  }

  // Vérification nom vide ou espaces uniquement
  if (name.trim() === '') {
    return { valid: false, error: 'EMPTY_NAME' };
  }

  // Détection XSS - balises HTML et patterns dangereux
  const xssPatterns = [
    /&lt;[^>]*>/,                    // Balises HTML
    /javascript:/i,               // javascript:
    /on\w+=/i,                    // onclick=, onerror=, etc.
    /&lt;script/i,                   // &lt;script
    /&lt;img/i,                      // &lt;img
    /&lt;iframe/i,                   // &lt;iframe
    /&lt;link/i,                     // &lt;link
    /&lt;style/i,                    // &lt;style
  ];

  for (const pattern of xssPatterns) {
    if (pattern.test(name)) {
      return { valid: false, error: 'XSS_DETECTED' };
    }
  }

  // Regex pour nom valide : lettres (avec accents), espaces, tirets, apostrophes
  // Autorise les caractères Unicode des alphabets latins avec accents
  const validNameRegex = /^[a-zA-ZàâäéèêëïîôùûüçœæÀÂÄÉÈÊËÏÎÔÙÛÜÇŒÆäöüßÄÖÜ\s\-']+$/;

  if (validNameRegex.test(name)) {
    return { valid: true, name };
  } else {
    return { valid: false, error: 'INVALID_CHARACTERS' };
  }
}

/**
 * Nettoie une chaîne de caractères en supprimant les éléments potentiellement dangereux (XSS).
 * Supprime les balises HTML, les attributs d'événements et les scripts.
 * 
 * @param {string} input - La chaîne à nettoyer
 * @returns {Object} Objet contenant { sanitized: string, wasModified: boolean }
 * @throws {Error} INVALID_ARGUMENT - Si aucun argument ou argument null/undefined
 * @throws {Error} INVALID_TYPE - Si l'argument n'est pas une chaîne de caractères
 * 
 * @example
 * // Texte sans XSS
 * const result = sanitizeInput('Bonjour le monde');
 * // { sanitized: 'Bonjour le monde', wasModified: false }
 * 
 * @example
 * // Texte avec XSS
 * const result = sanitizeInput('&lt;script>alert("xss")&lt;/script>');
 * // { sanitized: 'alert("xss")', wasModified: true }
 */
export function sanitizeInput(input) {
  // Validation des arguments
  if (input === undefined || input === null) {
    throw new Error('INVALID_ARGUMENT');
  }

  if (typeof input !== 'string') {
    throw new Error('INVALID_TYPE');
  }

  // Chaîne vide
  if (input === '') {
    return { sanitized: '', wasModified: false };
  }

  let sanitized = input;
  const original = input;

  // Supprimer les balises script et leur contenu
  sanitized = sanitized.replace(/&lt;script\b[^&lt;]*(?:(?!&lt;\/script>)&lt;[^&lt;]*)*&lt;\/script>/gi, '');

  // Supprimer les balises style et leur contenu
  sanitized = sanitized.replace(/&lt;style\b[^&lt;]*(?:(?!&lt;\/style>)&lt;[^&lt;]*)*&lt;\/style>/gi, '');

  // Supprimer toutes les balises HTML
  sanitized = sanitized.replace(/&lt;[^>]*>/g, '');

  // Supprimer javascript: et vbscript:
  sanitized = sanitized.replace(/javascript:/gi, '');
  sanitized = sanitized.replace(/vbscript:/gi, '');

  // Supprimer les attributs d'événements (onclick, onerror, onload, etc.)
  sanitized = sanitized.replace(/\bon\w+\s*=/gi, '');

  // Nettoyer les espaces multiples
  sanitized = sanitized.replace(/\s+/g, ' ').trim();

  // Si le texte original ne contenait que des balises, sanitized peut être vide
  // On préserve les espaces au début/fin si original les avait
  if (original.trim() === '' &amp;&amp; sanitized === '') {
    sanitized = '';
  }

  const wasModified = sanitized !== original;

  return { sanitized, wasModified };
}

/**
 * Valide un format d'adresse email standard.
 * 
 * @param {string} email - L'adresse email à valider
 * @returns {Object} Objet contenant { valid: boolean, email?: string, error?: string }
 * @throws {Error} INVALID_ARGUMENT - Si aucun argument ou argument null/undefined
 * @throws {Error} INVALID_TYPE - Si l'argument n'est pas une chaîne de caractères
 * 
 * @example
 * // Email valide
 * const result = isValidEmail('user@example.com');
 * // { valid: true, email: 'user@example.com' }
 * 
 * @example
 * // Email invalide
 * const result = isValidEmail('invalid-email');
 * // { valid: false, error: 'INVALID_FORMAT' }
 */
export function isValidEmail(email) {
  // Validation des arguments
  if (email === undefined || email === null) {
    throw new Error('INVALID_ARGUMENT');
  }

  if (typeof email !== 'string') {
    throw new Error('INVALID_TYPE');
  }

  // Regex pour email valide
  // - partie locale : lettres, chiffres, points, underscores, tirets, plus
  // - @ obligatoire
  // - domaine : lettres, chiffres, tirets
  // - TLD : au moins 2 caractères
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

  if (emailRegex.test(email)) {
    return { valid: true, email };
  } else {
    return { valid: false, error: 'INVALID_FORMAT' };
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-module.html">module</a></li><li><a href="module-validator.html">validator</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Fri Feb 06 2026 18:52:52 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
